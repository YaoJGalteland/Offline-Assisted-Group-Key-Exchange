
#include <stdio.h>
#include "miracl.h"
#include <time.h>

/* Use secp256k1 elliptic curve: y^2=x^3 + 7 */

/* Prime of the finite field */

char *ecp="FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F";

/* elliptic curve parameter B */

char *ecb="7";

/* Generator point of secp256k1 */

char *ecx="79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798";
char *ecy="483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8";

/* Order of the group generated by G, such that nG = Infinity */

char *ecn="FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141";


int main()
{
    int is,ii,ir;
    epoint *g,*ea,*eb,*es,*ei,*er;
    big sk_s,sk_i,sk_r,uk_r,ps,pi,pr,nn,key_initiator,key_responder,a,b,p,q,key,x,y,yd,z,pm[2];
    time_t seed;
    miracl *mip;
#ifndef MR_NOFULLWIDTH   
    mip=mirsys(36,0);
#else
    mip=mirsys(36,MAXBASE);
#endif
    sk_s=mirvar(0);
    sk_i=mirvar(0);
    sk_r=mirvar(0);
    uk_r=mirvar(0);
    ps=mirvar(0);
    pi=mirvar(0);
    pr=mirvar(0);
    key_initiator=mirvar(0);
    key_responder=mirvar(0);
    a=mirvar(0);
    b=mirvar(0);
    p=mirvar(0);
    q=mirvar(0);
    key=mirvar(0);   
    pm[0]=mirvar(0);
    pm[1]=mirvar(0);
    x=mirvar(0);
    y=mirvar(0);
    z=mirvar(0);
    yd=mirvar(0);
    nn=mirvar(0);

    time(&seed);
    irand((unsigned long)seed);   /* change parameter for different values */

/* Key exchange of this work is computed on secp256k1 */

    printf("Offline Group Key exchange using elliptic curves.... \n");
    convert(0,a);
    mip->IOBASE=16;
    cinstr(b,ecb);
    cinstr(p,ecp);      
    ecurve_init(a,b,p,MR_BEST);  /* Use PROJECTIVE if possible, else AFFINE coordinates */

    g=epoint_init();
    cinstr(x,ecx);
    cinstr(y,ecy);
    cinstr(nn,ecn);
    mip->IOBASE=10;
    epoint_set(x,y,0,g);
    ea=epoint_init();
    eb=epoint_init();
    es=epoint_init();
    ei=epoint_init();
    er=epoint_init();
    epoint_copy(g,ea);
    epoint_copy(g,eb);    
   
/* Generate private values for key exchange */
    bigbits(160,a); // Server generates private value sk_s
    copy(a,sk_s);
    ecurve_mult(sk_s,ea,es);
    is=epoint_get(es,ps,ps); /* <is,ps> is compressed form of Server's public key */

    bigbits(160,b);  // Initiator generates private value sk_i
    copy(b,sk_i);
    ecurve_mult(sk_i,eb,ei);
    ii=epoint_get(ei,pi,pi); /* <ii,pi> is compressed form of Initiator's public key */

    
    bigbits(160,b);  // Responder generates private value sk_r
    copy(b,sk_r);  
    xgcd(sk_r,nn,uk_r,yd,z); // unblind key uk_r

/* Initiator computes shared key key_initiator */
    printf("Initiator calculates Key=\n");
    epoint_set(ps,ps,is,es); /* decompress es */
    ecurve_mult(sk_i,es,es);
    epoint_get(es,key,key);
    cotnum(key,stdout);
    copy(key,key_initiator);

  
/* Responder blinds Initiator's public key */

    epoint_set(pi,pi,ii,ei); /* decompress ei */
    ecurve_mult(sk_r,ei,er);
    ir=epoint_get(er,pr,pr); /* <ir,pr> is compressed form of Responder's blinded public key */

    

/* Server blinds blinded key */

    epoint_set(pr,pr,ir,er); /* decompress er */
    ecurve_mult(sk_s,er,es);
    is=epoint_get(es,ps,ps); /* <is,ps> is compressed form of Server's public key */

/* Responder computes shared key */
   
    printf("Responder calculates Key=\n");
    epoint_set(ps,ps,is,es); /* decompress es */
    ecurve_mult(uk_r,es,es);
    epoint_get(es,key,key);
    cotnum(key,stdout);
    copy(key,key_responder);

    if (fcomp(key_initiator,key_responder) == 0)
        printf("Initiator and responder's keys are the same!\n");
    else
        printf("Initiator and responder's keys are not the same!\n");

    epoint_free(g);
    epoint_free(ea);
    epoint_free(eb);
    epoint_free(es);
    epoint_free(ei);
    epoint_free(er);

    return 0;
}

